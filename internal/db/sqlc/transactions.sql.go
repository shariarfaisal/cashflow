// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) as count FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?1
    AND (?2 = '' OR transaction_date >= ?2)
    AND (?3 = '' OR transaction_date <= ?3)
    AND (?4 = '' OR type = ?4 OR ?4 LIKE '%' || type || '%')
    AND (?5 = '' OR category_id = ?5 OR ?5 LIKE '%' || category_id || '%')
    AND (?6 = '' OR payment_status = ?6 OR ?6 LIKE '%' || payment_status || '%')
    AND (?7 = '' OR payment_method_id = ?7 OR ?7 LIKE '%' || payment_method_id || '%')
    AND (?8 = '' OR customer_vendor LIKE '%' || ?8 || '%')
    AND (?9 = '' OR description LIKE '%' || ?9 || '%')
`

type CountTransactionsParams struct {
	CreatedBy            string      `json:"created_by"`
	FromDate             interface{} `json:"from_date"`
	ToDate               interface{} `json:"to_date"`
	TypeFilter           interface{} `json:"type_filter"`
	CategoryFilter       interface{} `json:"category_filter"`
	PaymentStatusFilter  interface{} `json:"payment_status_filter"`
	PaymentMethodFilter  interface{} `json:"payment_method_filter"`
	CustomerVendorSearch interface{} `json:"customer_vendor_search"`
	DescriptionSearch    interface{} `json:"description_search"`
}

func (q *Queries) CountTransactions(ctx context.Context, arg CountTransactionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransactions,
		arg.CreatedBy,
		arg.FromDate,
		arg.ToDate,
		arg.TypeFilter,
		arg.CategoryFilter,
		arg.PaymentStatusFilter,
		arg.PaymentMethodFilter,
		arg.CustomerVendorSearch,
		arg.DescriptionSearch,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    type, description, amount, transaction_date,
    category_id, tags, customer_vendor, payment_method_id,
    payment_status, reference_number, invoice_number,
    notes, attachments, tax_amount, discount_amount,
    currency, exchange_rate, is_recurring, recurring_frequency,
    recurring_end_date, parent_transaction_id, created_by
) VALUES (
    ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?
) RETURNING id, type, description, amount, transaction_date, category_id, tags, customer_vendor, payment_method_id, payment_status, reference_number, invoice_number, notes, attachments, tax_amount, discount_amount, net_amount, currency, exchange_rate, is_recurring, recurring_frequency, recurring_end_date, parent_transaction_id, created_by, created_at, updated_at, deleted_at
`

type CreateTransactionParams struct {
	Type                string          `json:"type"`
	Description         string          `json:"description"`
	Amount              float64         `json:"amount"`
	TransactionDate     time.Time       `json:"transaction_date"`
	CategoryID          sql.NullString  `json:"category_id"`
	Tags                sql.NullString  `json:"tags"`
	CustomerVendor      sql.NullString  `json:"customer_vendor"`
	PaymentMethodID     sql.NullString  `json:"payment_method_id"`
	PaymentStatus       sql.NullString  `json:"payment_status"`
	ReferenceNumber     sql.NullString  `json:"reference_number"`
	InvoiceNumber       sql.NullString  `json:"invoice_number"`
	Notes               sql.NullString  `json:"notes"`
	Attachments         sql.NullString  `json:"attachments"`
	TaxAmount           sql.NullFloat64 `json:"tax_amount"`
	DiscountAmount      sql.NullFloat64 `json:"discount_amount"`
	Currency            sql.NullString  `json:"currency"`
	ExchangeRate        sql.NullFloat64 `json:"exchange_rate"`
	IsRecurring         sql.NullBool    `json:"is_recurring"`
	RecurringFrequency  sql.NullString  `json:"recurring_frequency"`
	RecurringEndDate    sql.NullTime    `json:"recurring_end_date"`
	ParentTransactionID sql.NullString  `json:"parent_transaction_id"`
	CreatedBy           string          `json:"created_by"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.Type,
		arg.Description,
		arg.Amount,
		arg.TransactionDate,
		arg.CategoryID,
		arg.Tags,
		arg.CustomerVendor,
		arg.PaymentMethodID,
		arg.PaymentStatus,
		arg.ReferenceNumber,
		arg.InvoiceNumber,
		arg.Notes,
		arg.Attachments,
		arg.TaxAmount,
		arg.DiscountAmount,
		arg.Currency,
		arg.ExchangeRate,
		arg.IsRecurring,
		arg.RecurringFrequency,
		arg.RecurringEndDate,
		arg.ParentTransactionID,
		arg.CreatedBy,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.Amount,
		&i.TransactionDate,
		&i.CategoryID,
		&i.Tags,
		&i.CustomerVendor,
		&i.PaymentMethodID,
		&i.PaymentStatus,
		&i.ReferenceNumber,
		&i.InvoiceNumber,
		&i.Notes,
		&i.Attachments,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.Currency,
		&i.ExchangeRate,
		&i.IsRecurring,
		&i.RecurringFrequency,
		&i.RecurringEndDate,
		&i.ParentTransactionID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
UPDATE transactions
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) DeleteTransaction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const getCustomerVendorSuggestions = `-- name: GetCustomerVendorSuggestions :many
SELECT DISTINCT customer_vendor, COUNT(*) as frequency
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
    AND customer_vendor IS NOT NULL
    AND customer_vendor != ''
    AND (? = '' OR type = ?)
    AND (? = '' OR customer_vendor LIKE '%' || ? || '%')
GROUP BY customer_vendor
ORDER BY frequency DESC, customer_vendor ASC
LIMIT ?
`

type GetCustomerVendorSuggestionsParams struct {
	CreatedBy string         `json:"created_by"`
	Column2   interface{}    `json:"column_2"`
	Type      string         `json:"type"`
	Column4   interface{}    `json:"column_4"`
	Column5   sql.NullString `json:"column_5"`
	Limit     int64          `json:"limit"`
}

type GetCustomerVendorSuggestionsRow struct {
	CustomerVendor sql.NullString `json:"customer_vendor"`
	Frequency      int64          `json:"frequency"`
}

func (q *Queries) GetCustomerVendorSuggestions(ctx context.Context, arg GetCustomerVendorSuggestionsParams) ([]GetCustomerVendorSuggestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerVendorSuggestions,
		arg.CreatedBy,
		arg.Column2,
		arg.Type,
		arg.Column4,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerVendorSuggestionsRow{}
	for rows.Next() {
		var i GetCustomerVendorSuggestionsRow
		if err := rows.Scan(&i.CustomerVendor, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyTransactionSummary = `-- name: GetDailyTransactionSummary :many
SELECT
    transaction_date,
    SUM(CASE WHEN type IN ('income', 'sale') THEN net_amount ELSE 0 END) as daily_income,
    SUM(CASE WHEN type IN ('expense', 'purchase') THEN net_amount ELSE 0 END) as daily_expense,
    SUM(CASE WHEN type IN ('income', 'sale') THEN net_amount ELSE -net_amount END) as daily_profit,
    COUNT(*) as transaction_count
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
    AND (? = '' OR transaction_date >= ?)
    AND (? = '' OR transaction_date <= ?)
GROUP BY transaction_date
ORDER BY transaction_date DESC
`

type GetDailyTransactionSummaryParams struct {
	CreatedBy         string      `json:"created_by"`
	Column2           interface{} `json:"column_2"`
	TransactionDate   time.Time   `json:"transaction_date"`
	Column4           interface{} `json:"column_4"`
	TransactionDate_2 time.Time   `json:"transaction_date_2"`
}

type GetDailyTransactionSummaryRow struct {
	TransactionDate  time.Time       `json:"transaction_date"`
	DailyIncome      sql.NullFloat64 `json:"daily_income"`
	DailyExpense     sql.NullFloat64 `json:"daily_expense"`
	DailyProfit      sql.NullFloat64 `json:"daily_profit"`
	TransactionCount int64           `json:"transaction_count"`
}

func (q *Queries) GetDailyTransactionSummary(ctx context.Context, arg GetDailyTransactionSummaryParams) ([]GetDailyTransactionSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyTransactionSummary,
		arg.CreatedBy,
		arg.Column2,
		arg.TransactionDate,
		arg.Column4,
		arg.TransactionDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyTransactionSummaryRow{}
	for rows.Next() {
		var i GetDailyTransactionSummaryRow
		if err := rows.Scan(
			&i.TransactionDate,
			&i.DailyIncome,
			&i.DailyExpense,
			&i.DailyProfit,
			&i.TransactionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDescriptionSuggestions = `-- name: GetDescriptionSuggestions :many
SELECT DISTINCT description, COUNT(*) as frequency
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
    AND description IS NOT NULL
    AND description != ''
    AND (? = '' OR type = ?)
    AND (? = '' OR description LIKE '%' || ? || '%')
GROUP BY description
ORDER BY frequency DESC, description ASC
LIMIT ?
`

type GetDescriptionSuggestionsParams struct {
	CreatedBy string         `json:"created_by"`
	Column2   interface{}    `json:"column_2"`
	Type      string         `json:"type"`
	Column4   interface{}    `json:"column_4"`
	Column5   sql.NullString `json:"column_5"`
	Limit     int64          `json:"limit"`
}

type GetDescriptionSuggestionsRow struct {
	Description string `json:"description"`
	Frequency   int64  `json:"frequency"`
}

func (q *Queries) GetDescriptionSuggestions(ctx context.Context, arg GetDescriptionSuggestionsParams) ([]GetDescriptionSuggestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDescriptionSuggestions,
		arg.CreatedBy,
		arg.Column2,
		arg.Type,
		arg.Column4,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDescriptionSuggestionsRow{}
	for rows.Next() {
		var i GetDescriptionSuggestionsRow
		if err := rows.Scan(&i.Description, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTrend = `-- name: GetMonthlyTrend :many
SELECT
    strftime('%Y-%m', transaction_date) as month,
    type,
    COUNT(*) as count,
    SUM(net_amount) as total_amount
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
    AND (? = '' OR transaction_date >= ?)
    AND (? = '' OR transaction_date <= ?)
GROUP BY month, type
ORDER BY month DESC
`

type GetMonthlyTrendParams struct {
	CreatedBy         string      `json:"created_by"`
	Column2           interface{} `json:"column_2"`
	TransactionDate   time.Time   `json:"transaction_date"`
	Column4           interface{} `json:"column_4"`
	TransactionDate_2 time.Time   `json:"transaction_date_2"`
}

type GetMonthlyTrendRow struct {
	Month       interface{}     `json:"month"`
	Type        string          `json:"type"`
	Count       int64           `json:"count"`
	TotalAmount sql.NullFloat64 `json:"total_amount"`
}

func (q *Queries) GetMonthlyTrend(ctx context.Context, arg GetMonthlyTrendParams) ([]GetMonthlyTrendRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTrend,
		arg.CreatedBy,
		arg.Column2,
		arg.TransactionDate,
		arg.Column4,
		arg.TransactionDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyTrendRow{}
	for rows.Next() {
		var i GetMonthlyTrendRow
		if err := rows.Scan(
			&i.Month,
			&i.Type,
			&i.Count,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTransactions = `-- name: GetRecentTransactions :many
SELECT id, type, description, amount, transaction_date, category_id, tags, customer_vendor, payment_method_id, payment_status, reference_number, invoice_number, notes, attachments, tax_amount, discount_amount, net_amount, currency, exchange_rate, is_recurring, recurring_frequency, recurring_end_date, parent_transaction_id, created_by, created_at, updated_at, deleted_at FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetRecentTransactionsParams struct {
	CreatedBy string `json:"created_by"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetRecentTransactions(ctx context.Context, arg GetRecentTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getRecentTransactions, arg.CreatedBy, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.Amount,
			&i.TransactionDate,
			&i.CategoryID,
			&i.Tags,
			&i.CustomerVendor,
			&i.PaymentMethodID,
			&i.PaymentStatus,
			&i.ReferenceNumber,
			&i.InvoiceNumber,
			&i.Notes,
			&i.Attachments,
			&i.TaxAmount,
			&i.DiscountAmount,
			&i.NetAmount,
			&i.Currency,
			&i.ExchangeRate,
			&i.IsRecurring,
			&i.RecurringFrequency,
			&i.RecurringEndDate,
			&i.ParentTransactionID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCustomersVendors = `-- name: GetTopCustomersVendors :many
SELECT
    customer_vendor,
    type,
    COUNT(*) as transaction_count,
    SUM(net_amount) as total_amount
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
    AND customer_vendor IS NOT NULL
    AND customer_vendor != ''
    AND (? = '' OR transaction_date >= ?)
    AND (? = '' OR transaction_date <= ?)
GROUP BY customer_vendor, type
ORDER BY total_amount DESC
LIMIT ?
`

type GetTopCustomersVendorsParams struct {
	CreatedBy         string      `json:"created_by"`
	Column2           interface{} `json:"column_2"`
	TransactionDate   time.Time   `json:"transaction_date"`
	Column4           interface{} `json:"column_4"`
	TransactionDate_2 time.Time   `json:"transaction_date_2"`
	Limit             int64       `json:"limit"`
}

type GetTopCustomersVendorsRow struct {
	CustomerVendor   sql.NullString  `json:"customer_vendor"`
	Type             string          `json:"type"`
	TransactionCount int64           `json:"transaction_count"`
	TotalAmount      sql.NullFloat64 `json:"total_amount"`
}

func (q *Queries) GetTopCustomersVendors(ctx context.Context, arg GetTopCustomersVendorsParams) ([]GetTopCustomersVendorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopCustomersVendors,
		arg.CreatedBy,
		arg.Column2,
		arg.TransactionDate,
		arg.Column4,
		arg.TransactionDate_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopCustomersVendorsRow{}
	for rows.Next() {
		var i GetTopCustomersVendorsRow
		if err := rows.Scan(
			&i.CustomerVendor,
			&i.Type,
			&i.TransactionCount,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, type, description, amount, transaction_date, category_id, tags, customer_vendor, payment_method_id, payment_status, reference_number, invoice_number, notes, attachments, tax_amount, discount_amount, net_amount, currency, exchange_rate, is_recurring, recurring_frequency, recurring_end_date, parent_transaction_id, created_by, created_at, updated_at, deleted_at FROM transactions
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) GetTransaction(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.Amount,
		&i.TransactionDate,
		&i.CategoryID,
		&i.Tags,
		&i.CustomerVendor,
		&i.PaymentMethodID,
		&i.PaymentStatus,
		&i.ReferenceNumber,
		&i.InvoiceNumber,
		&i.Notes,
		&i.Attachments,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.Currency,
		&i.ExchangeRate,
		&i.IsRecurring,
		&i.RecurringFrequency,
		&i.RecurringEndDate,
		&i.ParentTransactionID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTransactionStats = `-- name: GetTransactionStats :one
SELECT
    COUNT(CASE WHEN type IN ('income', 'sale') THEN 1 END) as total_income_count,
    COUNT(CASE WHEN type IN ('expense', 'purchase') THEN 1 END) as total_expense_count,
    COALESCE(SUM(CASE WHEN type IN ('income', 'sale') THEN net_amount ELSE 0 END), 0) as total_income,
    COALESCE(SUM(CASE WHEN type IN ('expense', 'purchase') THEN net_amount ELSE 0 END), 0) as total_expenses,
    COALESCE(SUM(CASE WHEN type IN ('income', 'sale') THEN net_amount ELSE -net_amount END), 0) as net_profit,
    COUNT(*) as total_transactions,
    COALESCE(AVG(net_amount), 0) as average_transaction,
    COALESCE(SUM(CASE WHEN type IN ('income', 'sale') AND payment_status = 'pending' THEN net_amount ELSE 0 END), 0) as pending_income,
    COALESCE(SUM(CASE WHEN type IN ('expense', 'purchase') AND payment_status = 'pending' THEN net_amount ELSE 0 END), 0) as pending_expenses
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?1
    AND (?2 = '' OR transaction_date >= ?2)
    AND (?3 = '' OR transaction_date <= ?3)
`

type GetTransactionStatsParams struct {
	CreatedBy string      `json:"created_by"`
	FromDate  interface{} `json:"from_date"`
	ToDate    interface{} `json:"to_date"`
}

type GetTransactionStatsRow struct {
	TotalIncomeCount   int64       `json:"total_income_count"`
	TotalExpenseCount  int64       `json:"total_expense_count"`
	TotalIncome        interface{} `json:"total_income"`
	TotalExpenses      interface{} `json:"total_expenses"`
	NetProfit          interface{} `json:"net_profit"`
	TotalTransactions  int64       `json:"total_transactions"`
	AverageTransaction interface{} `json:"average_transaction"`
	PendingIncome      interface{} `json:"pending_income"`
	PendingExpenses    interface{} `json:"pending_expenses"`
}

func (q *Queries) GetTransactionStats(ctx context.Context, arg GetTransactionStatsParams) (GetTransactionStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionStats, arg.CreatedBy, arg.FromDate, arg.ToDate)
	var i GetTransactionStatsRow
	err := row.Scan(
		&i.TotalIncomeCount,
		&i.TotalExpenseCount,
		&i.TotalIncome,
		&i.TotalExpenses,
		&i.NetProfit,
		&i.TotalTransactions,
		&i.AverageTransaction,
		&i.PendingIncome,
		&i.PendingExpenses,
	)
	return i, err
}

const getTransactionsByCategory = `-- name: GetTransactionsByCategory :many
SELECT
    category_id,
    type,
    COUNT(*) as count,
    SUM(net_amount) as total_amount
FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?1
    AND (?2 = '' OR transaction_date >= ?2)
    AND (?3 = '' OR transaction_date <= ?3)
    AND category_id IS NOT NULL
GROUP BY category_id, type
ORDER BY total_amount DESC
`

type GetTransactionsByCategoryParams struct {
	CreatedBy string      `json:"created_by"`
	FromDate  interface{} `json:"from_date"`
	ToDate    interface{} `json:"to_date"`
}

type GetTransactionsByCategoryRow struct {
	CategoryID  sql.NullString  `json:"category_id"`
	Type        string          `json:"type"`
	Count       int64           `json:"count"`
	TotalAmount sql.NullFloat64 `json:"total_amount"`
}

func (q *Queries) GetTransactionsByCategory(ctx context.Context, arg GetTransactionsByCategoryParams) ([]GetTransactionsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByCategory, arg.CreatedBy, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByCategoryRow{}
	for rows.Next() {
		var i GetTransactionsByCategoryRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.Type,
			&i.Count,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, type, description, amount, transaction_date, category_id, tags, customer_vendor, payment_method_id, payment_status, reference_number, invoice_number, notes, attachments, tax_amount, discount_amount, net_amount, currency, exchange_rate, is_recurring, recurring_frequency, recurring_end_date, parent_transaction_id, created_by, created_at, updated_at, deleted_at FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?1
    AND (?2 = '' OR transaction_date >= ?2)
    AND (?3 = '' OR transaction_date <= ?3)
    AND (?4 = '' OR type = ?4 OR ?4 LIKE '%' || type || '%')
    AND (?5 = '' OR category_id = ?5 OR ?5 LIKE '%' || category_id || '%')
    AND (?6 = '' OR payment_status = ?6 OR ?6 LIKE '%' || payment_status || '%')
    AND (?7 = '' OR payment_method_id = ?7 OR ?7 LIKE '%' || payment_method_id || '%')
    AND (?8 = '' OR customer_vendor LIKE '%' || ?8 || '%')
    AND (?9 = '' OR description LIKE '%' || ?9 || '%')
ORDER BY transaction_date DESC, created_at DESC
LIMIT ?11 OFFSET ?10
`

type ListTransactionsParams struct {
	CreatedBy            string      `json:"created_by"`
	FromDate             interface{} `json:"from_date"`
	ToDate               interface{} `json:"to_date"`
	TypeFilter           interface{} `json:"type_filter"`
	CategoryFilter       interface{} `json:"category_filter"`
	PaymentStatusFilter  interface{} `json:"payment_status_filter"`
	PaymentMethodFilter  interface{} `json:"payment_method_filter"`
	CustomerVendorSearch interface{} `json:"customer_vendor_search"`
	DescriptionSearch    interface{} `json:"description_search"`
	Offset               int64       `json:"offset"`
	Limit                int64       `json:"limit"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions,
		arg.CreatedBy,
		arg.FromDate,
		arg.ToDate,
		arg.TypeFilter,
		arg.CategoryFilter,
		arg.PaymentStatusFilter,
		arg.PaymentMethodFilter,
		arg.CustomerVendorSearch,
		arg.DescriptionSearch,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.Amount,
			&i.TransactionDate,
			&i.CategoryID,
			&i.Tags,
			&i.CustomerVendor,
			&i.PaymentMethodID,
			&i.PaymentStatus,
			&i.ReferenceNumber,
			&i.InvoiceNumber,
			&i.Notes,
			&i.Attachments,
			&i.TaxAmount,
			&i.DiscountAmount,
			&i.NetAmount,
			&i.Currency,
			&i.ExchangeRate,
			&i.IsRecurring,
			&i.RecurringFrequency,
			&i.RecurringEndDate,
			&i.ParentTransactionID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTransactions = `-- name: SearchTransactions :many
SELECT id, type, description, amount, transaction_date, category_id, tags, customer_vendor, payment_method_id, payment_status, reference_number, invoice_number, notes, attachments, tax_amount, discount_amount, net_amount, currency, exchange_rate, is_recurring, recurring_frequency, recurring_end_date, parent_transaction_id, created_by, created_at, updated_at, deleted_at FROM transactions
WHERE deleted_at IS NULL
    AND created_by = ?
    AND (
        description LIKE '%' || ? || '%'
        OR customer_vendor LIKE '%' || ? || '%'
        OR reference_number LIKE '%' || ? || '%'
        OR invoice_number LIKE '%' || ? || '%'
        OR notes LIKE '%' || ? || '%'
    )
ORDER BY transaction_date DESC, created_at DESC
LIMIT ? OFFSET ?
`

type SearchTransactionsParams struct {
	CreatedBy string         `json:"created_by"`
	Column2   sql.NullString `json:"column_2"`
	Column3   sql.NullString `json:"column_3"`
	Column4   sql.NullString `json:"column_4"`
	Column5   sql.NullString `json:"column_5"`
	Column6   sql.NullString `json:"column_6"`
	Limit     int64          `json:"limit"`
	Offset    int64          `json:"offset"`
}

func (q *Queries) SearchTransactions(ctx context.Context, arg SearchTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, searchTransactions,
		arg.CreatedBy,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.Amount,
			&i.TransactionDate,
			&i.CategoryID,
			&i.Tags,
			&i.CustomerVendor,
			&i.PaymentMethodID,
			&i.PaymentStatus,
			&i.ReferenceNumber,
			&i.InvoiceNumber,
			&i.Notes,
			&i.Attachments,
			&i.TaxAmount,
			&i.DiscountAmount,
			&i.NetAmount,
			&i.Currency,
			&i.ExchangeRate,
			&i.IsRecurring,
			&i.RecurringFrequency,
			&i.RecurringEndDate,
			&i.ParentTransactionID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET
    type = ?,
    description = ?,
    amount = ?,
    transaction_date = ?,
    category_id = ?,
    tags = ?,
    customer_vendor = ?,
    payment_method_id = ?,
    payment_status = ?,
    reference_number = ?,
    invoice_number = ?,
    notes = ?,
    attachments = ?,
    tax_amount = ?,
    discount_amount = ?,
    currency = ?,
    exchange_rate = ?,
    is_recurring = ?,
    recurring_frequency = ?,
    recurring_end_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND deleted_at IS NULL
RETURNING id, type, description, amount, transaction_date, category_id, tags, customer_vendor, payment_method_id, payment_status, reference_number, invoice_number, notes, attachments, tax_amount, discount_amount, net_amount, currency, exchange_rate, is_recurring, recurring_frequency, recurring_end_date, parent_transaction_id, created_by, created_at, updated_at, deleted_at
`

type UpdateTransactionParams struct {
	Type               string          `json:"type"`
	Description        string          `json:"description"`
	Amount             float64         `json:"amount"`
	TransactionDate    time.Time       `json:"transaction_date"`
	CategoryID         sql.NullString  `json:"category_id"`
	Tags               sql.NullString  `json:"tags"`
	CustomerVendor     sql.NullString  `json:"customer_vendor"`
	PaymentMethodID    sql.NullString  `json:"payment_method_id"`
	PaymentStatus      sql.NullString  `json:"payment_status"`
	ReferenceNumber    sql.NullString  `json:"reference_number"`
	InvoiceNumber      sql.NullString  `json:"invoice_number"`
	Notes              sql.NullString  `json:"notes"`
	Attachments        sql.NullString  `json:"attachments"`
	TaxAmount          sql.NullFloat64 `json:"tax_amount"`
	DiscountAmount     sql.NullFloat64 `json:"discount_amount"`
	Currency           sql.NullString  `json:"currency"`
	ExchangeRate       sql.NullFloat64 `json:"exchange_rate"`
	IsRecurring        sql.NullBool    `json:"is_recurring"`
	RecurringFrequency sql.NullString  `json:"recurring_frequency"`
	RecurringEndDate   sql.NullTime    `json:"recurring_end_date"`
	ID                 string          `json:"id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.Type,
		arg.Description,
		arg.Amount,
		arg.TransactionDate,
		arg.CategoryID,
		arg.Tags,
		arg.CustomerVendor,
		arg.PaymentMethodID,
		arg.PaymentStatus,
		arg.ReferenceNumber,
		arg.InvoiceNumber,
		arg.Notes,
		arg.Attachments,
		arg.TaxAmount,
		arg.DiscountAmount,
		arg.Currency,
		arg.ExchangeRate,
		arg.IsRecurring,
		arg.RecurringFrequency,
		arg.RecurringEndDate,
		arg.ID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.Amount,
		&i.TransactionDate,
		&i.CategoryID,
		&i.Tags,
		&i.CustomerVendor,
		&i.PaymentMethodID,
		&i.PaymentStatus,
		&i.ReferenceNumber,
		&i.InvoiceNumber,
		&i.Notes,
		&i.Attachments,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.Currency,
		&i.ExchangeRate,
		&i.IsRecurring,
		&i.RecurringFrequency,
		&i.RecurringEndDate,
		&i.ParentTransactionID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
